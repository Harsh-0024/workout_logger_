{% extends 'base.html' %}
{% block content %}
<div class="row justify-content-center">
    <div class="col-12 col-md-10 col-lg-8">
        <div class="card">
            <div class="text-center mb-4 mb-md-5">
                <div class="mb-3 mb-md-4">
                    <i class="bi bi-journal-plus" style="font-size: clamp(3rem, 10vw, 4rem); color: var(--gold-primary); opacity: 0.6;"></i>
                </div>
                <h2 class="fw-bold mb-2 mb-md-3" style="font-size: clamp(1.5rem, 6vw, 2rem);">Log Session</h2>
                <p class="text-muted mb-0" style="font-size: clamp(0.875rem, 3vw, var(--fs-lg));">Record your workout performance</p>
            </div>

            <form action="/log" method="POST">
                <div class="mb-3 mb-md-4 position-relative">
                    <label class="form-label text-muted mb-2 mb-md-3 tracking-wide" style="font-size: var(--fs-xs); text-transform: uppercase; letter-spacing: 2px; font-weight: 600;">
                        Workout Data
                    </label>
                    <textarea name="workout_text" class="form-control" rows="10" autofocus
                        placeholder="Chest & Triceps 1&#10;Bench Press: 100kg x 5, 100kg x 5, 100kg x 5&#10;Incline DB Press: 35kg x 8, 35kg x 8, 35kg x 8&#10;...">{{ workout_text or '' }}</textarea>
                    <div id="exerciseSuggestions" class="exercise-suggestions" style="display: none;"></div>
                    <div class="log-meta text-muted mt-2">
                        <span class="log-hint"><i class="bi bi-info-circle me-1"></i>Supports BW, BW+10, BW-20, or split weight/reps lines</span>
                        <span id="lineCount" class="log-stats">0 exercises • 0 reps</span>
                    </div>
                </div>
                <button type="submit" class="btn btn-gold-solid w-100 mb-3">
                    <i class="bi bi-check-circle-fill me-2"></i>Analyze & Save
                </button>
            </form>

            <div class="text-center pt-3 pt-md-4 border-top" style="border-color: var(--border-subtle) !important;">
                <a href="/" class="text-muted text-decoration-none small hover-gold tracking-wide">
                    <i class="bi bi-arrow-left me-1"></i>Cancel
                </a>
            </div>
        </div>
    </div>
</div>
<script type="application/json" id="exerciseData">{{ exercise_list | tojson if exercise_list is defined else '[]' }}</script>
<style>
    .exercise-suggestions {
        position: absolute;
        left: 0;
        right: 0;
        top: calc(100% - 12px);
        background: rgba(15, 15, 17, 0.98);
        border: 1px solid var(--border-subtle);
        border-radius: 12px;
        box-shadow: var(--shadow-md);
        z-index: 5;
        max-height: 200px;
        overflow-y: auto;
        padding: 6px;
    }

    .exercise-suggestion {
        padding: 8px 12px;
        border-radius: 8px;
        cursor: pointer;
        font-size: var(--fs-sm);
        color: var(--text-secondary);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .exercise-suggestion strong {
        color: var(--text-primary);
        font-weight: 600;
    }

    .exercise-suggestion.active,
    .exercise-suggestion:hover {
        background: rgba(212, 175, 55, 0.12);
        color: var(--text-primary);
    }

    .log-meta {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        font-size: var(--fs-xs);
        flex-wrap: wrap;
    }

    .log-stats {
        padding: 6px 12px;
        border-radius: 999px;
        background: rgba(212, 175, 55, 0.12);
        color: var(--gold-bright);
        font-weight: 600;
        letter-spacing: 0.5px;
    }

    @media (max-width: 576px) {
        .log-meta {
            flex-direction: column;
            align-items: flex-start;
        }

        .log-stats {
            align-self: flex-start;
        }
    }
</style>
<script>
    (function() {
        const textarea = document.querySelector('textarea[name="workout_text"]');
        const counter = document.getElementById('lineCount');
        const suggestionBox = document.getElementById('exerciseSuggestions');
        const exerciseData = document.getElementById('exerciseData');
        const exerciseList = exerciseData ? JSON.parse(exerciseData.textContent || '[]') : [];
        if (!textarea || !counter) return;

        const isDataLine = (line) => {
            const trimmed = line.trim().toLowerCase();
            if (!trimmed) return false;
            return /^(?:,|-?\d|bw)/.test(trimmed);
        };

        const expandShorthand = (values) => {
            if (!values.length) return [];
            if (values.length === 1) return [values[0], values[0], values[0]];
            if (values.length === 2) return [values[0], values[1], values[1]];
            return values;
        };

        const updateCount = () => {
            const value = textarea.value || '';
            const rawLines = value.split(/\r?\n/).map((line) => line.trim()).filter(Boolean);
            if (rawLines.length <= 1) {
                counter.textContent = '0 exercises • 0 reps';
                return;
            }

            const lines = rawLines.slice(1);
            let exerciseCount = 0;
            let repCount = 0;
            let i = 0;

            while (i < lines.length) {
                const line = lines[i];
                if (!line) {
                    i += 1;
                    continue;
                }

                let dataPart = '';
                let consumed = 1;

                if (line.includes(' - [')) {
                    const parts = line.split(' - [');
                    let tail = '';
                    if (parts[1]) {
                        const bracketIndex = parts[1].indexOf(']');
                        if (bracketIndex !== -1) {
                            tail = parts[1].slice(bracketIndex + 1).trim();
                        }
                    }
                    dataPart = tail ? tail.replace(/^[-:]+\s*/, '') : '';

                    if (!dataPart && i + 1 < lines.length && isDataLine(lines[i + 1])) {
                        const dataLine = lines[i + 1];
                        dataPart = dataLine.trim();
                        consumed += 1;

                        if (!dataPart.includes(',') && i + 2 < lines.length && isDataLine(lines[i + 2])) {
                            const repsLine = lines[i + 2].trim();
                            dataPart = `${dataPart}, ${repsLine}`;
                            consumed += 1;
                        }
                    }
                } else {
                    const tokens = line.split(/\s+/);
                    let firstNumIdx = -1;
                    for (let idx = 0; idx < tokens.length; idx += 1) {
                        const token = tokens[idx].toLowerCase();
                        if (/^-?\d/.test(token) || token.startsWith(',') || token.startsWith('bw')) {
                            firstNumIdx = idx;
                            break;
                        }
                    }
                    if (firstNumIdx !== -1) {
                        dataPart = tokens.slice(firstNumIdx).join(' ').trim();
                    }
                }

                if (dataPart) {
                    exerciseCount += 1;
                    const match = dataPart.match(/(bw[+-]?\d*|-?\d+(?:\.\d+)?)\s*x\s*\d+/gi);
                    if (match) {
                        const reps = match.map((item) => {
                            const repMatch = item.match(/x\s*(\d+)/i);
                            return repMatch ? Number(repMatch[1]) : 0;
                        }).filter((val) => !Number.isNaN(val));
                        const expanded = expandShorthand(reps);
                        repCount += expanded.reduce((sum, val) => sum + val, 0);
                    } else if (dataPart.includes(',')) {
                        const parts = dataPart.split(',', 1);
                        const weights = parts[0].replace(/(kg|lbs|lb)/gi, ' ').replace(/,/g, ' ').trim();
                        const weightTokens = weights ? weights.split(/\s+/).filter(Boolean) : [];
                        const repsTokens = parts[1]
                            ? parts[1].replace(/(kg|lbs|lb)/gi, ' ').replace(/,/g, ' ').trim().split(/\s+/).filter(Boolean)
                            : [];
                        const weightCount = expandShorthand(weightTokens).length;
                        const reps = expandShorthand(
                            repsTokens.map((val) => Number(val)).filter((val) => !Number.isNaN(val))
                        );
                        if (reps.length) {
                            repCount += reps.reduce((sum, val) => sum + val, 0);
                        } else if (weightCount) {
                            repCount += weightCount;
                        }
                    } else {
                        const weights = dataPart.replace(/(kg|lbs|lb)/gi, ' ').replace(/,/g, ' ').trim();
                        const weightTokens = weights ? weights.split(/\s+/).filter(Boolean) : [];
                        const weightCount = expandShorthand(weightTokens).length;
                        repCount += weightCount;
                    }
                }

                i += consumed;
            }

            counter.textContent = `${exerciseCount} exercise${exerciseCount === 1 ? '' : 's'} • ${repCount} rep${repCount === 1 ? '' : 's'}`;
        };

        if (suggestionBox && Array.isArray(exerciseList) && exerciseList.length) {
            let activeIndex = -1;
            let activeSuggestions = [];

            const getLineContext = () => {
                const value = textarea.value || '';
                const cursor = textarea.selectionStart || 0;
                const lineStart = value.lastIndexOf('\n', cursor - 1) + 1;
                const lineEnd = value.indexOf('\n', cursor);
                const end = lineEnd === -1 ? value.length : lineEnd;
                const line = value.slice(lineStart, end);
                return { value, cursor, lineStart, lineEnd: end, line };
            };

            const getPrefixData = (line) => {
                const trimmed = line.trim();
                if (!trimmed) return null;
                const lower = trimmed.toLowerCase();
                if (/^[\d,.-]/.test(lower) || lower.startsWith('bw')) return null;

                const separatorPatterns = [' - [', ' - ', ' – ', ' — ', ':'];
                let separatorIndex = line.length;
                separatorPatterns.forEach((pattern) => {
                    const idx = line.indexOf(pattern);
                    if (idx !== -1 && idx < separatorIndex) {
                        separatorIndex = idx;
                    }
                });

                const leading = line.match(/^\s*/)[0] || '';
                const prefix = line.slice(leading.length, separatorIndex).trim();
                const suffix = line.slice(separatorIndex);
                if (!prefix || prefix.length < 2) return null;
                return { leading, prefix, suffix };
            };

            const renderSuggestions = () => {
                if (!activeSuggestions.length) {
                    suggestionBox.style.display = 'none';
                    suggestionBox.innerHTML = '';
                    activeIndex = -1;
                    return;
                }
                suggestionBox.style.display = 'block';
                suggestionBox.innerHTML = activeSuggestions
                    .map((name, idx) => {
                        const active = idx === activeIndex ? 'active' : '';
                        return `<div class="exercise-suggestion ${active}" data-index="${idx}">${name}</div>`;
                    })
                    .join('');
            };

            const applySuggestion = (index) => {
                const suggestion = activeSuggestions[index];
                if (!suggestion) return;
                const ctx = getLineContext();
                const prefixData = getPrefixData(ctx.line);
                if (!prefixData) return;

                const replacement = `${prefixData.leading}${suggestion}${prefixData.suffix}`;
                const newValue = `${ctx.value.slice(0, ctx.lineStart)}${replacement}${ctx.value.slice(ctx.lineEnd)}`;
                textarea.value = newValue;
                const newCursor = ctx.lineStart + replacement.length;
                textarea.setSelectionRange(newCursor, newCursor);
                updateCount();
                updateSuggestions();
            };

            const updateSuggestions = () => {
                const ctx = getLineContext();
                const prefixData = getPrefixData(ctx.line);
                if (!prefixData) {
                    activeSuggestions = [];
                    renderSuggestions();
                    return;
                }

                const query = prefixData.prefix.toLowerCase();
                activeSuggestions = exerciseList
                    .filter((name) => name.toLowerCase().startsWith(query))
                    .slice(0, 6);
                activeIndex = activeSuggestions.length ? 0 : -1;
                renderSuggestions();
            };

            suggestionBox.addEventListener('click', (event) => {
                const item = event.target.closest('.exercise-suggestion');
                if (!item) return;
                const index = Number(item.dataset.index);
                if (Number.isInteger(index)) {
                    applySuggestion(index);
                }
            });

            textarea.addEventListener('keydown', (event) => {
                if (!activeSuggestions.length) return;
                if (event.key === 'ArrowDown') {
                    event.preventDefault();
                    activeIndex = (activeIndex + 1) % activeSuggestions.length;
                    renderSuggestions();
                } else if (event.key === 'ArrowUp') {
                    event.preventDefault();
                    activeIndex = (activeIndex - 1 + activeSuggestions.length) % activeSuggestions.length;
                    renderSuggestions();
                } else if (event.key === 'Tab') {
                    event.preventDefault();
                    applySuggestion(activeIndex === -1 ? 0 : activeIndex);
                }
            });

            textarea.addEventListener('blur', () => {
                setTimeout(() => {
                    activeSuggestions = [];
                    renderSuggestions();
                }, 150);
            });

            textarea.addEventListener('input', updateSuggestions);
            updateSuggestions();
        }

        textarea.addEventListener('input', updateCount);
        updateCount();
    })();
</script>
{% endblock %}