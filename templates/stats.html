{% extends 'base.html' %}
{% block content %}
<div class="row">
    <div class="col-12">
        <div class="card">
            <div class="d-flex flex-column flex-md-row justify-content-between align-items-start align-items-md-center mb-4 mb-md-5 flex-wrap gap-3 pb-3 pb-md-4 border-bottom" style="border-color: var(--border-subtle) !important;">
                <div>
                    <h2 class="fw-bold mb-2" style="font-size: clamp(1.5rem, 5vw, 2rem);">Progress Tracking</h2>
                    <p class="text-muted mb-0" style="font-size: var(--fs-sm);">Analyze your performance over time</p>
                </div>
            </div>

            <div class="row mb-4">
                <div class="col-12">
                    <label class="text-muted mb-2 d-block" style="font-size: var(--fs-xs); text-transform: uppercase; letter-spacing: 1.5px; font-weight: 600;">
                        <i class="bi bi-search me-2"></i>proeSearch Exercise
                    </label>
                    <div class="position-relative">
                        <input 
                            id="exerciseSearch" 
                            class="form-control" 
                            type="text" 
                            placeholder="Type to search exercises..." 
                            autocomplete="off"
                            oninput="handleSearchInput()" 
                            onfocus="showSuggestions()" 
                            onkeydown="handleKeyDown(event)"
                            style="font-size: var(--fs-sm);"
                        >
                        <div id="suggestionsList" class="position-absolute w-100 border rounded-2 mt-1" style="display: none; max-height: 300px; overflow-y: auto; z-index: 1000;">
                        </div>
                    </div>
                    <script type="application/json" id="exerciseOptionsData">{{ exercise_options | tojson }}</script>
                </div>
            </div>

            <!-- Chart Container -->
            <div class="chart-container mb-3" style="position: relative; height: clamp(240px, 38vh, 400px); width:100%; min-height: 240px;">
                <canvas id="progressChart"></canvas>
                <div id="chartPlaceholder" class="position-absolute top-0 start-0 w-100 h-100" style="pointer-events: none;"></div>
            </div>

            <!-- Filters below chart -->
            <div class="stats-filters mb-3">
                <div class="d-flex flex-column flex-sm-row gap-2 gap-sm-3">
                    <div class="flex-fill">
                        <label class="text-muted mb-1 d-block stats-filter-label">Time range</label>
                        <div class="d-flex gap-2 range-pill-group">
                            <button class="range-pill" data-range="7">7 days</button>
                            <button class="range-pill active" data-range="30">30 days</button>
                            <button class="range-pill" data-range="90">90 days</button>
                            <button class="range-pill" data-range="180">180 days</button>
                        </div>
                    </div>
                    <div>
                        <label class="text-muted mb-1 d-block stats-filter-label">Moving average window</label>
                        <div class="d-flex gap-2 ma-pill-group">
                            <button class="ma-pill active" data-ma="7">7d</button>
                            <button class="ma-pill" data-ma="14">14d</button>
                            <button class="ma-pill" data-ma="30">30d</button>
                        </div>
                    </div>
                    <div id="metricControls" style="display: none;">
                        <label class="text-muted mb-1 d-block stats-filter-label">Metric</label>
                        <div class="d-flex gap-2 metric-pill-group">
                            <button class="metric-pill active" data-metric="e1rm">e1RM</button>
                            <button class="metric-pill" data-metric="top_weight">Top Weight</button>
                            <button class="metric-pill" data-metric="tonnage">Tonnage</button>
                            <button class="metric-pill" data-metric="effective_tonnage">Effective Tonnage</button>
                        </div>
                    </div>
                </div>
            </div>

            {% if bw_warning_enabled and bw_exercises %}
            <div id="bwStatsAlert" class="alert alert-warning mb-4" role="alert" style="display: none; background: rgba(212, 175, 55, 0.12); border-color: rgba(212, 175, 55, 0.35); color: var(--platinum);">
                <i class="bi bi-info-circle me-2"></i>
                Set your bodyweight in Settings to see accurate BW volume and 1RM for <span id="bwStatsExercise" class="fw-semibold"></span>.
            </div>
            <script type="application/json" id="bwExercisesData">{{ bw_exercises | tojson }}</script>
            {% endif %}

            <!-- Stats Summary -->
            <div id="statsSummary" class="row g-2 g-md-3 mb-3 stats-summary" style="display: none;">
                <div class="col-6 col-md-3">
                    <div class="stat-card">
                        <div class="stat-value" id="current1RM">-</div>
                        <div class="stat-label" id="current1RMLabel">Current 1RM</div>
                    </div>
                </div>
                <div class="col-6 col-md-3">
                    <div class="stat-card">
                        <div class="stat-value" id="max1RM">-</div>
                        <div class="stat-label" id="max1RMLabel">Max 1RM</div>
                    </div>
                </div>
                <div class="col-6 col-md-3">
                    <div class="stat-card">
                        <div class="stat-value" id="improvement">-</div>
                        <div class="stat-label" id="improvementLabel">Improvement</div>
                    </div>
                </div>
                <div class="col-6 col-md-3">
                    <div class="stat-card">
                        <div class="stat-value" id="improvementPct">-</div>
                        <div class="stat-label" id="improvementPctLabel">% Change</div>
                    </div>
                </div>
            </div>

            <div class="text-center mt-5 pt-4 border-top" style="border-color: var(--border-subtle) !important;">
                <a href="/" class="text-muted text-decoration-none small hover-gold tracking-wide">
                    <i class="bi bi-arrow-left me-1"></i>Back Home
                </a>
            </div>
        </div>
    </div>
</div>

<style>
    #suggestionsList {
        background: var(--card-bg, #1a1a1a);
        border-color: var(--border-subtle, #333) !important;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
    }
    
    [data-theme="light"] #suggestionsList {
        background: #ffffff;
        border-color: #d1d5db !important;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    
    #suggestionsList .suggestion-item {
        color: var(--text-primary, #e5e5e5);
    }
    
    [data-theme="light"] #suggestionsList .suggestion-item {
        color: #1f2937;
    }
    
    #suggestionsList .border-top {
        border-color: var(--border-subtle, #333) !important;
    }
    
    [data-theme="light"] #suggestionsList .border-top {
        border-color: #e5e7eb !important;
    }

    .chart-container {
        background: var(--card-bg, #141414);
        border: 1px solid var(--border-subtle, rgba(212, 175, 55, 0.2));
        border-radius: 22px;
        padding: 12px;
    }

    [data-theme="light"] .chart-container {
        background: #fffaf1;
        border-color: rgba(148, 126, 86, 0.35);
        box-shadow: 0 10px 30px rgba(148, 126, 86, 0.08);
    }

    .stats-filters {
        background: var(--card-bg, #141414);
        border: 1px solid var(--border-subtle, rgba(212, 175, 55, 0.2));
        border-radius: 20px;
        padding: 0.85rem 1rem;
    }

    [data-theme="light"] .stats-filters {
        background: #fffaf1;
        border-color: rgba(148, 126, 86, 0.35);
        box-shadow: 0 8px 24px rgba(148, 126, 86, 0.08);
    }

    .range-pill-group,
    .ma-pill-group,
    .metric-pill-group {
        flex-wrap: nowrap;
    }

    .range-pill, .ma-pill, .metric-pill {
        background: rgba(22, 22, 22, 0.7);
        color: var(--text-muted, #b5b5b5);
        border-radius: 999px;
        padding: 0.45rem 0.95rem;
        font-size: 0.78rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s ease;
        border: 1px solid rgba(212, 175, 55, 0.25);
        white-space: nowrap;
        text-align: center;
    }

    .ma-pill, .metric-pill {
        padding: 0.35rem 0.8rem;
        font-size: 0.72rem;
    }

    [data-theme="light"] .range-pill,
    [data-theme="light"] .ma-pill,
    [data-theme="light"] .metric-pill {
        background: #fffdf8;
        color: #6b6b6b;
        border-color: rgba(148, 126, 86, 0.35);
    }

    .range-pill:hover, .ma-pill:hover, .metric-pill:hover {
        background: rgba(212, 175, 55, 0.15);
        color: #D4AF37;
    }

    .range-pill.active, .ma-pill.active, .metric-pill.active {
        background: #D4AF37;
        color: #171717;
        font-weight: 600;
        border-color: #D4AF37;
        box-shadow: 0 6px 18px rgba(212, 175, 55, 0.35);
    }

    [data-theme="light"] .range-pill.active,
    [data-theme="light"] .ma-pill.active,
    [data-theme="light"] .metric-pill.active {
        background: #D4AF37;
        color: #000;
    }

    .stats-filter-label {
        font-size: 0.65rem;
        text-transform: uppercase;
        letter-spacing: 0.4px;
        font-weight: 600;
    }

    .stats-summary .stat-card {
        border: 1px solid var(--border-subtle, rgba(212, 175, 55, 0.2));
        background: var(--card-bg, #141414);
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.18);
    }

    [data-theme="light"] .stats-summary .stat-card {
        background: #ffffff;
        border-color: rgba(148, 126, 86, 0.35);
        box-shadow: 0 10px 24px rgba(148, 126, 86, 0.08);
    }

    @media (max-width: 576px) {
        .chart-container {
            padding: 10px;
            border-radius: 18px;
        }

        .stats-filters {
            margin-bottom: var(--space-sm);
            padding: 0.7rem 0.85rem;
        }

        .range-pill-group {
            flex-wrap: nowrap !important;
            gap: 0.3rem;
        }

        .ma-pill-group,
        .metric-pill-group {
            gap: 0.4rem;
        }

        .range-pill {
            flex: 1 1 0;
            min-width: 0;
            padding: 0.3rem 0.5rem;
            font-size: 0.68rem;
        }

        .ma-pill, .metric-pill {
            flex: 1 1 0;
            min-width: 0;
            padding: 0.28rem 0.5rem;
            font-size: 0.65rem;
        }

        .stats-summary .stat-card {
            padding: 12px;
            border-radius: 14px;
            min-height: 92px;
        }

        .stats-summary .stat-value {
            font-size: 1.2rem;
        }

        .stats-summary .stat-label {
            font-size: 0.6rem;
            letter-spacing: 1.4px;
        }
    }
</style>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script>
    let myChart = null;

    const exerciseOptionsEl = document.getElementById('exerciseOptionsData');
    const exerciseOptions = exerciseOptionsEl ? JSON.parse(exerciseOptionsEl.textContent || '[]') : [];
    let currentExercise = '';
    let selectedSuggestionIndex = -1;
    let currentDaysRange = 30;
    let currentMAWindow = 7;
    let currentMetric = 'e1rm';
    let fullChartData = null;

    function getMetricConfig(metricKey, data) {
        const unit = (data && data.unit) ? data.unit : '';
        if (unit === 'percent') {
            return { key: 'data', label: 'Average Change (%)', unit: 'percent', suffix: '%' };
        }

        const configs = {
            e1rm: { key: 'e1rm', label: 'Estimated 1RM (kg)', suffix: '' },
            top_weight: { key: 'top_weight', label: 'Top Weight (kg)', suffix: '' },
            tonnage: { key: 'tonnage', label: 'Tonnage (kg)', suffix: '' },
            effective_tonnage: { key: 'effective_tonnage', label: 'Effective Tonnage (kg)', suffix: '' },
        };
        return configs[metricKey] || configs.e1rm;
    }

    function getSeriesValues(data, metricKey) {
        if (!data) return [];
        if (data.unit === 'percent') return data.data || [];
        const series = data.series || {};
        const config = getMetricConfig(metricKey, data);
        return series[config.key] || data.data || [];
    }

    function computeStats(values) {
        const cleaned = (values || []).map(v => Number(v)).filter(v => Number.isFinite(v));
        if (!cleaned.length) return {};
        const first = cleaned[0];
        const last = cleaned[cleaned.length - 1];
        const max = Math.max(...cleaned);
        const min = Math.min(...cleaned);
        const avg = cleaned.reduce((sum, v) => sum + v, 0) / cleaned.length;
        const improvement = last - first;
        const improvementPct = (first !== 0) ? (improvement / first) * 100 : 0;
        return {
            current: last,
            max,
            min,
            avg,
            improvement,
            improvement_pct: improvementPct,
        };
    }

    function hasBooleanOperators(query) {
        if (!query) return false;
        if (/\b(?:and|or|not)\b/i.test(query)) return true;
        if (/[()+*!]/.test(query)) return true;
        if (/(^|\s)-\w/.test(query) || /\s-\s/.test(query)) return true;
        return false;
    }

    function tokenizeBooleanQuery(query) {
        const raw = String(query || '').trim();
        if (!raw) return [];
        const prepared = raw
            .replace(/([()])/g, ' $1 ')
            .replace(/([+*])/g, ' $1 ')
            .replace(/!/g, ' ! ')
            .replace(/\s+/g, ' ')
            .trim();
        const parts = prepared ? prepared.split(' ') : [];
        const tokens = [];

        parts.forEach((part) => {
            if (!part) return;
            const lower = part.toLowerCase();
            if (lower === 'and' || lower === '+') {
                tokens.push({ type: 'OP', value: 'AND' });
                return;
            }
            if (lower === 'or') {
                tokens.push({ type: 'OP', value: 'OR' });
                return;
            }
            if (lower === 'not' || lower === '!' || lower === '-') {
                tokens.push({ type: 'OP', value: 'NOT' });
                return;
            }
            if (lower === '*' ) {
                tokens.push({ type: 'OP', value: 'AND' });
                return;
            }
            if (part === '(') {
                tokens.push({ type: 'LPAREN' });
                return;
            }
            if (part === ')') {
                tokens.push({ type: 'RPAREN' });
                return;
            }
            if (part.startsWith('-') && part.length > 1) {
                tokens.push({ type: 'OP', value: 'NOT' });
                tokens.push({ type: 'TERM', value: part.slice(1).toLowerCase() });
                return;
            }
            if (part.startsWith('!') && part.length > 1) {
                tokens.push({ type: 'OP', value: 'NOT' });
                tokens.push({ type: 'TERM', value: part.slice(1).toLowerCase() });
                return;
            }
            tokens.push({ type: 'TERM', value: part.toLowerCase() });
        });

        return tokens;
    }

    function insertImplicitAnd(tokens) {
        const result = [];
        const isTerm = (token) => token && token.type === 'TERM';
        const isRightGroup = (token) => token && (token.type === 'TERM' || token.type === 'LPAREN' || (token.type === 'OP' && token.value === 'NOT'));
        const isLeftGroup = (token) => token && (token.type === 'TERM' || token.type === 'RPAREN');

        tokens.forEach((token, idx) => {
            const prev = result[result.length - 1];
            if (idx > 0 && isLeftGroup(prev) && isRightGroup(token)) {
                result.push({ type: 'OP', value: 'AND' });
            }
            result.push(token);
        });
        return result;
    }

    function toRpn(tokens) {
        const output = [];
        const ops = [];
        const prec = { OR: 1, AND: 2, NOT: 3 };
        const rightAssoc = { NOT: true };

        for (const token of tokens) {
            if (token.type === 'TERM') {
                output.push(token);
                continue;
            }
            if (token.type === 'OP') {
                while (ops.length) {
                    const top = ops[ops.length - 1];
                    if (top.type !== 'OP') break;
                    const topPrec = prec[top.value] || 0;
                    const curPrec = prec[token.value] || 0;
                    if ((rightAssoc[token.value] && curPrec < topPrec) || (!rightAssoc[token.value] && curPrec <= topPrec)) {
                        output.push(ops.pop());
                        continue;
                    }
                    break;
                }
                ops.push(token);
                continue;
            }
            if (token.type === 'LPAREN') {
                ops.push(token);
                continue;
            }
            if (token.type === 'RPAREN') {
                while (ops.length && ops[ops.length - 1].type !== 'LPAREN') {
                    output.push(ops.pop());
                }
                if (!ops.length) return null;
                ops.pop();
            }
        }

        while (ops.length) {
            const op = ops.pop();
            if (op.type === 'LPAREN' || op.type === 'RPAREN') return null;
            output.push(op);
        }
        return output;
    }

    function evalRpn(rpn, text) {
        const stack = [];
        for (const token of rpn) {
            if (token.type === 'TERM') {
                stack.push(text.includes(token.value));
                continue;
            }
            if (token.type === 'OP') {
                if (token.value === 'NOT') {
                    if (!stack.length) return false;
                    stack.push(!stack.pop());
                    continue;
                }
                if (stack.length < 2) return false;
                const b = stack.pop();
                const a = stack.pop();
                stack.push(token.value === 'AND' ? (a && b) : (a || b));
            }
        }
        return stack.length ? stack[0] : false;
    }

    function buildBooleanMatcher(query) {
        const tokens = insertImplicitAnd(tokenizeBooleanQuery(query));
        if (!tokens.length) return null;
        if (!tokens.some(token => token.type === 'TERM')) return null;
        const rpn = toRpn(tokens);
        if (!rpn) return null;
        return (value) => evalRpn(rpn, value);
    }

    function getFilteredOptions(filterText) {
        const normalized = filterText.trim().toLowerCase();
        if (!normalized) return exerciseOptions;
        if (!hasBooleanOperators(filterText)) {
            return exerciseOptions.filter(option => 
                (option.label || '').toLowerCase().includes(normalized)
            );
        }

        const matcher = buildBooleanMatcher(filterText);
        if (!matcher) {
            return exerciseOptions.filter(option => 
                (option.label || '').toLowerCase().includes(normalized)
            );
        }
        return exerciseOptions.filter(option => {
            const haystack = (option.label || option.value || '').toLowerCase();
            return matcher(haystack);
        });
    }

    function renderSuggestions(filterText = '') {
        const suggestionsList = document.getElementById('suggestionsList');
        if (!suggestionsList) return;

        const filtered = getFilteredOptions(filterText);
        suggestionsList.innerHTML = '';

        // Add "Overall Progress" option only if no filter or filter is empty
        const showOverall = !filterText.trim();
        if (showOverall) {
            const overallItem = document.createElement('div');
            overallItem.className = 'suggestion-item px-3 py-2';
            overallItem.style.cssText = 'cursor: pointer; transition: background 0.15s;';
            overallItem.innerHTML = '<i class="bi bi-graph-up me-2 text-gold"></i><span class="fw-semibold">Overall Progress</span>';
            overallItem.onmouseover = () => { overallItem.style.background = 'rgba(212, 175, 55, 0.25)'; };
            overallItem.onmouseout = () => { if (selectedSuggestionIndex !== 0) overallItem.style.background = 'transparent'; };
            overallItem.onclick = () => selectExercise('');
            overallItem.dataset.index = '0';
            suggestionsList.appendChild(overallItem);
        }

        // Add separator if there are exercises and overall is shown
        if (showOverall && filtered.length > 0) {
            const separator = document.createElement('div');
            separator.className = 'border-top my-1';
            suggestionsList.appendChild(separator);
        }

        // Add filtered exercises
        const startIdx = showOverall ? 1 : 0;
        filtered.forEach((option, idx) => {
            const item = document.createElement('div');
            item.className = 'suggestion-item px-3 py-2';
            item.style.cssText = 'cursor: pointer; transition: background 0.15s;';
            item.textContent = option.label || option.value;
            item.onmouseover = () => { item.style.background = 'rgba(212, 175, 55, 0.25)'; };
            item.onmouseout = () => { if (selectedSuggestionIndex !== idx + startIdx) item.style.background = 'transparent'; };
            item.onclick = () => selectExercise(option.value);
            item.dataset.index = String(idx + startIdx);
            suggestionsList.appendChild(item);
        });

        if (filtered.length === 0 && filterText.trim()) {
            const noResults = document.createElement('div');
            noResults.className = 'px-3 py-2 text-muted';
            noResults.textContent = 'No exercises found';
            suggestionsList.appendChild(noResults);
        }
        
        selectedSuggestionIndex = -1;
    }

    function showSuggestions() {
        const suggestionsList = document.getElementById('suggestionsList');
        if (suggestionsList) {
            suggestionsList.style.display = 'block';
            selectedSuggestionIndex = -1;
        }
    }

    function hideSuggestions() {
        setTimeout(() => {
            const suggestionsList = document.getElementById('suggestionsList');
            if (suggestionsList) {
                suggestionsList.style.display = 'none';
            }
        }, 200);
    }

    function selectExercise(exerciseValue) {
        const searchInput = document.getElementById('exerciseSearch');
        currentExercise = exerciseValue;
        
        if (exerciseValue) {
            const option = exerciseOptions.find(opt => opt.value === exerciseValue);
            if (searchInput && option) {
                searchInput.value = option.label || option.value;
            }
        } else {
            if (searchInput) {
                searchInput.value = '';
            }
        }
        
        hideSuggestions();
        loadChart();
    }

    function handleSearchInput() {
        const searchInput = document.getElementById('exerciseSearch');
        const filterText = searchInput ? searchInput.value : '';
        renderSuggestions(filterText);
        showSuggestions();
        
        // Auto-select if exact match or single result
        const filtered = getFilteredOptions(filterText);
        if (filtered.length === 1) {
            currentExercise = filtered[0].value;
            loadChart();
        } else if (filterText.trim() === '') {
            currentExercise = '';
            loadChart();
        }
    }

    function handleKeyDown(event) {
        const suggestionsList = document.getElementById('suggestionsList');
        if (!suggestionsList || suggestionsList.style.display === 'none') return;
        
        const items = suggestionsList.querySelectorAll('.suggestion-item');
        if (items.length === 0) return;
        
        if (event.key === 'ArrowDown') {
            event.preventDefault();
            selectedSuggestionIndex = (selectedSuggestionIndex + 1) % items.length;
            updateSelectedSuggestion(items);
        } else if (event.key === 'ArrowUp') {
            event.preventDefault();
            selectedSuggestionIndex = selectedSuggestionIndex <= 0 ? items.length - 1 : selectedSuggestionIndex - 1;
            updateSelectedSuggestion(items);
        } else if (event.key === 'Enter') {
            event.preventDefault();
            if (selectedSuggestionIndex >= 0 && selectedSuggestionIndex < items.length) {
                items[selectedSuggestionIndex].click();
            }
        } else if (event.key === 'Escape') {
            hideSuggestions();
        }
    }

    function updateSelectedSuggestion(items) {
        items.forEach((item, idx) => {
            if (idx === selectedSuggestionIndex) {
                item.style.background = 'rgba(212, 175, 55, 0.25)';
                item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
            } else {
                item.style.background = 'transparent';
            }
        });
    }

    // Close suggestions when clicking outside
    document.addEventListener('click', (e) => {
        const searchInput = document.getElementById('exerciseSearch');
        const suggestionsList = document.getElementById('suggestionsList');
        if (searchInput && suggestionsList && !searchInput.contains(e.target) && !suggestionsList.contains(e.target)) {
            hideSuggestions();
            selectedSuggestionIndex = -1;
        }
    });

    function movingAverage(values, window) {
        if (!values || values.length === 0) return [];
        const result = [];
        for (let i = 0; i < values.length; i++) {
            const start = Math.max(0, i - window + 1);
            const slice = values.slice(start, i + 1);
            const avg = slice.reduce((sum, v) => sum + (v || 0), 0) / slice.length;
            result.push(avg);
        }
        return result;
    }

    function filterDataByRange(data, days) {
        if (!data || !data.labels || !data.data) return data;
        if (days <= 0 || data.labels.length === 0) return data;
        
        const cutoffIndex = Math.max(0, data.labels.length - days);
        return {
            ...data,
            labels: data.labels.slice(cutoffIndex),
            data: data.data.slice(cutoffIndex),
            weight: data.weight ? data.weight.slice(cutoffIndex) : [],
            reps: data.reps ? data.reps.slice(cutoffIndex) : [],
            volume: data.volume ? data.volume.slice(cutoffIndex) : [],
            effective_volume: data.effective_volume ? data.effective_volume.slice(cutoffIndex) : [],
            quality: data.quality ? data.quality.slice(cutoffIndex) : [],
            quality_adjusted_1rm: data.quality_adjusted_1rm ? data.quality_adjusted_1rm.slice(cutoffIndex) : [],
            series: data.series ? Object.fromEntries(Object.entries(data.series).map(([k, v]) => [k, (v || []).slice(cutoffIndex)])) : {},
        };
    }

    function getRangeBounds(labels, days) {
        if (!labels || labels.length === 0) {
            return { startIndex: 0, endIndex: 0 };
        }
        const total = labels.length;
        const startIndex = Math.max(0, total - days);
        return { startIndex, endIndex: total - 1 };
    }

    function renderChart(data, label) {
        fullChartData = data;
        const filteredData = filterDataByRange(data, currentDaysRange);
        const ctx = document.getElementById('progressChart').getContext('2d');

        const metricControls = document.getElementById('metricControls');
        if (metricControls) {
            metricControls.style.display = (currentExercise && filteredData.unit !== 'percent') ? 'block' : 'none';
        }

        const formatShortLabel = (rawLabel) => {
            if (!rawLabel) return '';
            const parts = String(rawLabel).split('-');
            if (parts.length === 3) {
                const year = Number(parts[0]);
                const month = Number(parts[1]);
                const day = Number(parts[2]);
                if (!Number.isNaN(year) && !Number.isNaN(month) && !Number.isNaN(day)) {
                    return new Date(year, month - 1, day).toLocaleDateString('en-US', {
                        month: 'short',
                        day: 'numeric'
                    });
                }
            }
            return rawLabel;
        };

        const rawLabels = data.labels || [];
        const rangeBounds = getRangeBounds(rawLabels, currentDaysRange);
        const shortLabels = rawLabels.map(formatShortLabel);

        const metricConfig = getMetricConfig(currentMetric, data);
        const primaryValues = getSeriesValues(data, currentMetric);
        const maValues = movingAverage(primaryValues || [], currentMAWindow);
        const xMinLabel = shortLabels[rangeBounds.startIndex] || shortLabels[0] || '';
        const xMaxLabel = shortLabels[rangeBounds.endIndex] || shortLabels[shortLabels.length - 1] || '';

        if (document.getElementById('chartPlaceholder')) {
            document.getElementById('chartPlaceholder').style.display = 'none';
        }

        const summary = computeStats(getSeriesValues(filteredData, currentMetric));
        if (summary && Object.keys(summary).length) {
            const isPercent = filteredData.unit === 'percent';
            document.getElementById('statsSummary').style.display = 'flex';
            const currentValue = summary.current || 0;
            const maxValue = summary.max || 0;
            const improvementValue = summary.improvement || 0;
            const improvementPctValue = isPercent ? (summary.avg || 0) : (summary.improvement_pct || 0);

            document.getElementById('current1RM').textContent = isPercent ? `${currentValue.toFixed(1)}%` : currentValue.toFixed(1);
            document.getElementById('max1RM').textContent = isPercent ? `${maxValue.toFixed(1)}%` : maxValue.toFixed(1);
            document.getElementById('improvement').textContent = isPercent
                ? (improvementValue >= 0 ? '+' : '') + improvementValue.toFixed(1) + '%'
                : (improvementValue >= 0 ? '+' : '') + improvementValue.toFixed(1);
            document.getElementById('improvementPct').textContent = isPercent
                ? (improvementPctValue >= 0 ? '+' : '') + improvementPctValue.toFixed(1) + '%'
                : (improvementPctValue >= 0 ? '+' : '') + improvementPctValue.toFixed(1) + '%';

            document.getElementById('current1RMLabel').textContent = isPercent ? 'Current Change' : `Current ${metricConfig.label}`;
            document.getElementById('max1RMLabel').textContent = isPercent ? 'Best Change' : `Max ${metricConfig.label}`;
            document.getElementById('improvementLabel').textContent = isPercent ? 'Net Change' : 'Improvement';
            document.getElementById('improvementPctLabel').textContent = isPercent ? 'Avg Change' : '% Change';
        } else {
            document.getElementById('statsSummary').style.display = 'none';
        }

        const isLightMode = document.documentElement.getAttribute('data-theme') === 'light';
        const pointBorderColor = isLightMode ? '#FFFFFF' : '#000000';
        const pointHoverBorderColor = isLightMode ? '#F5F3F0' : '#FFFFFF';
        const isPercent = filteredData.unit === 'percent';
        const yTickCallback = (value) => isPercent ? `${value}%` : value;
        const tooltipValueSuffix = isPercent ? '%' : '';
        const tickColor = isLightMode ? '#6B7280' : '#9CA3AF';
        const gridColor = isLightMode ? 'rgba(148, 163, 184, 0.25)' : 'rgba(148, 163, 184, 0.18)';
        const gradient = ctx.createLinearGradient(0, 0, 0, 320);
        gradient.addColorStop(0, 'rgba(212, 175, 55, 0.35)');
        gradient.addColorStop(1, 'rgba(212, 175, 55, 0.05)');

        const avgColor = isLightMode ? 'rgba(212, 175, 55, 0.6)' : 'rgba(212, 175, 55, 0.5)';

        const primarySeries = getSeriesValues(data, currentMetric);
        const qualitySeries = (data && data.quality) ? data.quality : [];
        const showQuality = !!(qualitySeries && qualitySeries.length);

        if (myChart) {
            myChart.data.labels = shortLabels;
            myChart.data.datasets[0].data = primarySeries || [];
            myChart.data.datasets[0].backgroundColor = gradient;
            myChart.data.datasets[0].label = metricConfig.label;
            if (myChart.data.datasets[1]) {
                myChart.data.datasets[1].data = maValues;
                myChart.data.datasets[1].borderColor = avgColor;
            }
            if (myChart.data.datasets[2]) {
                myChart.data.datasets[2].data = showQuality ? qualitySeries : [];
                myChart.data.datasets[2].borderColor = '#2FA772';
                myChart.data.datasets[2].borderDash = [];
                myChart.data.datasets[2].borderWidth = 2.5;
                myChart.data.datasets[2].hidden = !showQuality;
            }
            myChart.options.scales.y.ticks.callback = yTickCallback;
            myChart.options.scales.x.min = xMinLabel;
            myChart.options.scales.x.max = xMaxLabel;
            myChart.options.scales.x.ticks.maxTicksLimit = window.innerWidth > 768 ? Math.min(Math.floor(window.innerWidth / 80), 15) : 4;
            myChart.update();
        } else {
            myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: shortLabels,
                    datasets: [
                        {
                            label: metricConfig.label,
                            data: primarySeries || [],
                            borderColor: '#D4AF37',
                            backgroundColor: gradient,
                            borderWidth: 3,
                            tension: 0.35,
                            fill: true,
                            pointRadius: 2,
                            pointHoverRadius: 5,
                            pointBackgroundColor: '#D4AF37',
                            pointBorderWidth: 0,
                            pointHoverBackgroundColor: '#F4D03F',
                            pointHoverBorderWidth: 0
                        },
                        {
                            label: `Moving avg (${currentMAWindow}d)`,
                            data: maValues,
                            borderColor: avgColor,
                            borderWidth: 2,
                            borderDash: [6, 6],
                            fill: false,
                            tension: 0.35,
                            pointRadius: 0,
                            pointHoverRadius: 0
                        },
                        {
                            label: 'Performance (%)',
                            data: showQuality ? qualitySeries : [],
                            borderColor: '#2FA772',
                            borderWidth: 2.5,
                            borderDash: [],
                            fill: false,
                            tension: 0.35,
                            pointRadius: 0,
                            pointHoverRadius: 0,
                            yAxisID: 'y1',
                            hidden: !showQuality,
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.9)',
                            titleColor: '#D4AF37',
                            bodyColor: '#FFFFFF',
                            borderColor: '#D4AF37',
                            borderWidth: 2,
                            padding: 16,
                            displayColors: false,
                            titleFont: { size: 14, weight: 'bold' },
                            bodyFont: { size: 13 },
                            cornerRadius: 12,
                            titleSpacing: 8,
                            bodySpacing: 6,
                            callbacks: {
                                label: (context) => {
                                    const value = context.parsed.y;
                                    if (value === null || value === undefined) return '';
                                    return `${value.toFixed(1)}${tooltipValueSuffix}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            grid: { 
                                color: gridColor,
                                lineWidth: 1
                            },
                            ticks: { 
                                color: tickColor,
                                font: { size: 10, weight: '500' },
                                padding: 12,
                                callback: yTickCallback
                            },
                            beginAtZero: false
                        },
                        y1: {
                            position: 'right',
                            grid: { display: false },
                            ticks: {
                                color: tickColor,
                                font: { size: 10, weight: '500' },
                                padding: 12,
                                callback: (value) => `${value}%`,
                            },
                            min: 0,
                            max: 100,
                        },
                        x: {
                            grid: { display: false },
                            ticks: { 
                                color: tickColor,
                                font: { size: 10, weight: '500' },
                                padding: 10,
                                autoSkip: true,
                                maxTicksLimit: window.innerWidth > 768 ? Math.min(Math.floor(window.innerWidth / 80), 15) : 4,
                                maxRotation: 0
                            },
                            min: xMinLabel,
                            max: xMaxLabel
                        }
                    }
                }
            });
        }
    }

    function loadAverageChart() {
        fetch('/stats/data/average')
            .then(response => response.json())
            .then(data => {
                renderChart(data, 'Average Change (%)');
            })
            .catch(error => {
                console.error('Error loading average chart:', error);
            });
    }

    function loadChart() {
        const exercise = currentExercise;
        const placeholder = document.getElementById('chartPlaceholder');
        const bwAlert = document.getElementById('bwStatsAlert');
        const bwLabel = document.getElementById('bwStatsExercise');
        const bwData = document.getElementById('bwExercisesData');
        const bwExercises = bwData ? JSON.parse(bwData.textContent || '[]') : [];

        const updateBwAlert = (target) => {
            if (!bwAlert) return;
            if (target && bwExercises.includes(target)) {
                if (bwLabel) {
                    bwLabel.textContent = target;
                }
                bwAlert.style.display = 'block';
                return;
            }
            bwAlert.style.display = 'none';
        };

        if (!exercise) {
            updateBwAlert('');
            loadAverageChart();
            return;
        }

        updateBwAlert(exercise);

        fetch(`/stats/data/${encodeURIComponent(exercise)}`)
            .then(response => response.json())
            .then(data => {
                if (placeholder) placeholder.style.display = 'none';
                renderChart(data, '');
            })
            .catch(error => {
                console.error('Error loading chart:', error);
            });
    }

    // Handle time range filter buttons
    document.querySelectorAll('.range-pill').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.range-pill').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            currentDaysRange = parseInt(btn.dataset.range);
            if (fullChartData) {
                renderChart(fullChartData, fullChartData.exercise || 'Progress');
            }
        });
    });

    // Handle moving average filter buttons
    document.querySelectorAll('.ma-pill').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.ma-pill').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            currentMAWindow = parseInt(btn.dataset.ma);
            if (fullChartData) {
                renderChart(fullChartData, fullChartData.exercise || 'Progress');
            }
        });
    });

    document.querySelectorAll('.metric-pill').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.metric-pill').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            currentMetric = btn.dataset.metric;
            if (fullChartData) {
                renderChart(fullChartData, fullChartData.exercise || 'Progress');
            }
        });
    });

    // Auto-select exercise from URL parameter
    window.addEventListener('DOMContentLoaded', () => {
        const urlParams = new URLSearchParams(window.location.search);
        const exerciseParam = urlParams.get('exercise');
        renderSuggestions();
        
        if (exerciseParam) {
            const option = exerciseOptions.find(opt => opt.value === exerciseParam);
            if (option) {
                selectExercise(exerciseParam);
                return;
            }
        }
        loadAverageChart();
    });

    // Handle window resize to update chart tick limits
    window.addEventListener('resize', function() {
        if (myChart) {
            const newTickLimit = window.innerWidth > 768 ? Math.min(Math.floor(window.innerWidth / 80), 15) : 4;
            myChart.options.scales.x.ticks.maxTicksLimit = newTickLimit;
            myChart.update('none'); // Update without animation for better performance
        }
    });
</script>
{% endblock %}